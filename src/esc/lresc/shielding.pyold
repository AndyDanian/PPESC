from optparse import Values
from libl import *

def correction_to_calculate(lresc_amounts: list = None, tensor: bool = False):
    """
    Turn on or off lresc_amounts corrections
    Args:
        paramagneitc (list): Paramagnetic amount to calculate
    """
    triplet_lineal_amount: bool = False
    singlet_lineal_amount: bool = False
    triplet_quadratic_amount: bool = False
    singlet_quadratic_amount: bool = False
    para_nr: bool = False
    dia_nr: bool = False
    dia_lineal: bool = False
    diaavs: bool = False

    sddxy: bool = False
    sddxz: bool = False
    sddyx: bool = False
    sddyz: bool = False
    sddzx: bool = False
    sddzy: bool = False
    lsdsoxy: bool = False
    lsdsoxz: bool = False
    lsdsoyx: bool = False
    lsdsoyz: bool = False
    lsdsozx: bool = False
    lsdsozy: bool = False
    sdbsoxy: bool = False
    sdbsoxz: bool = False
    sdbsoyx: bool = False
    sdbsoyz: bool = False
    sdbsozx: bool = False
    sdbsozy: bool = False
    if tensor:
        sddxy: bool = True
        sddxz: bool = True
        sddyx: bool = True
        sddyz: bool = True
        sddzx: bool = True
        sddzy: bool = True
        lsdsoxy: bool = True
        lsdsoxz: bool = True
        lsdsoyx: bool = True
        lsdsoyz: bool = True
        lsdsozx: bool = True
        lsdsozy: bool = True
        sdbsoxy: bool = True
        sdbsoxz: bool = True
        sdbsoyx: bool = True
        sdbsoyz: bool = True
        sdbsozx: bool = True
        sdbsozy: bool = True


    if not lresc_amounts:
        return {
        "paranr": True,
        # Lineal -- Triplet
        "fclap": True, "sddxx": True, "sddyy": True, "sddzz": True,
        "sddxy": sddxy, "sddxz": sddxz, "sddyx": sddyx,
        "sddyz": sddyz, "sddzx": sddzx, "sddzy": sddzy,
        "fcbso": True, "sdbsoxx": True, "sdbsoyy": True,
        "sdbsozz": True, "sdbsoxy": sdbsoxy, "sdbsoxz": sdbsoxz,
        "sdbsoyx": sdbsoyx, "sdbsoyz": sdbsoyz, "sdbsozx": sdbsozx,
        "sdbsozy": sdbsozy,
        # Lineal -- Singlet
        "lpsokin": True, "lkinpso": True,
        # Quadratic -- Triplet
        "lfcso" : True,
        "lsdsoxx": True, "lsdsoyy": True, "lsdsozz": True,
        "lsdsoxy": lsdsoxy, "lsdsoxz": lsdsoxz, "lsdsoyx": lsdsoyx,
        "lsdsoyz": lsdsoyz, "lsdsozx": lsdsozx, "lsdsozy": lsdsozy,
        # Quadratic -- Singlet
        "lpsodw": True, "lpsomv": True,
        # Diamagnetic
        # NR
        "dianr": True,
        # Lineal singlet responses
        "a2mv": True, "a2dw": True,
        # Averages
        "fc": True, "psooz": True, "dnske": True
        }, {"para_nr": True, "triplet_lineal_amount": True, "singlet_lineal_amount": True,
        "triplet_quadratic_amount": True, "singlet_quadratic_amount": True,
        "dia_singlet_lineal": True}, {"dia_nr": True, "dia_avs": True}
    else:
        if "paranr" in lresc_amounts or "nr" in lresc_amounts: para_nr = True
        if "dianr" in lresc_amounts or "nr" in lresc_amounts: dia_nr = True
        if "diaavs" in lresc_amounts or "avs" in lresc_amounts: diaavs = True
        if ("fclap" in lresc_amounts or "sdlap" in lresc_amounts or
            "fcbso" in lresc_amounts or "sdbso" in lresc_amounts): triplet_lineal_amount = True
        if "lpsokin" in lresc_amounts or "lkinpso" in lresc_amounts: singlet_lineal_amount = True
        if ("lfcso" in lresc_amounts or "lsdsoxx" in lresc_amounts or
            "lsdsoyy" in lresc_amounts or "lsdsozz" in lresc_amounts): triplet_quadratic_amount = True
        if ("lpsodw" in lresc_amounts or "lpsomv" in lresc_amounts): singlet_quadratic_amount = True
        if ("a2mv" in lresc_amounts or "a2dw" in lresc_amounts): dia_lineal = True
        return {
        "paranr": "paranr" in lresc_amounts,
        # Lineal -- Triplet
        "fclap": "fclap" in lresc_amounts, "sddxx": "sddxx" in lresc_amounts,
        "sddyy": "sddyy" in lresc_amounts,"sddzz": "sddzz" in lresc_amounts,
        "sddxy": "sddxy" in lresc_amounts, "sddxz": "sddxz" in lresc_amounts,
        "sddyx": "sddyx" in lresc_amounts, "sddyz": "sddyz" in lresc_amounts,
        "sddzx": "sddzx" in lresc_amounts, "sddzy": "sddzy" in lresc_amounts,
        "fcbso": "fcbso" in lresc_amounts, "sdbsoxx": "sdbsoxx" in lresc_amounts,
        "sdbsoyy": "sdbsoyy" in lresc_amounts, "sdbsozz": "sdbsozz" in lresc_amounts,
        "sdbsoxy": "sdbsoxy" in lresc_amounts, "sdbsoxz": "sdbsoxz" in lresc_amounts,
        "sdbsoyx": "sdbsoyx" in lresc_amounts, "sdbsoyz": "sdbsoyz" in lresc_amounts,
        "sdbsozy": "sdbsozy" in lresc_amounts, "sdbsozx": "sdbsozx" in lresc_amounts,
        # Lineal -- Singlet
        "lpsokin": "lpsokin" in lresc_amounts, "lkinpso": "lkinpso" in lresc_amounts,
        # Quadratic -- Triplet
        "lfcso" : "lfcso" in lresc_amounts,
        "lsdsoxx": "lsdsoxx" in lresc_amounts, "lsdsoyy": "lsdsoyy" in lresc_amounts,
        "lsdsozz": "lsdsozz" in lresc_amounts, "lsdsoxy": "lsdsoxy" in lresc_amounts,
        "lsdsoxz": "lsdsoxz" in lresc_amounts, "lsdsoyx": "lsdsoyx" in lresc_amounts,
        "lsdsoyz": "lsdsoyz" in lresc_amounts, "lsdsozx": "lsdsozx" in lresc_amounts,
        "lsdsozy": "lsdsozy" in lresc_amounts,
        # Quadratic -- Singlet
        "lpsodw": "lpsodw" in lresc_amounts, "lpsomv": "lpsomv" in lresc_amounts,
        # Diamagnetic
        # NR
        "dianr": "dianr" in lresc_amounts,
        # Lineal singlet responses
        "a2mv": "a2mv" in lresc_amounts, "a2dw": "a2dw" in lresc_amounts,
        # Averages
        "fc": "fc" in lresc_amounts, "psooz": "psooz" in lresc_amounts, "dnske": "dnske" in lresc_amounts
        }, {"para_nr": para_nr, "triplet_lineal_amount": triplet_lineal_amount, "singlet_lineal_amount": singlet_lineal_amount,
        "triplet_quadratic_amount": triplet_quadratic_amount, "singlet_quadratic_amount": singlet_quadratic_amount,
        "dia_singlet_lineal": dia_lineal}, {"dia_nr": dia_nr, "dia_avs": diaavs}

def run_shielding_lresc(wf: wave_function = None, lresc_amounts: list = None,
                        lresc_consts: dict = None, atom: list = None,
                        principal_propagator_approximation: str = None,
                        driver_time: drv_time = None, verbose: int = 0,
                        tensor: bool = False,
                        verbose_response: int = -1,
                        verbose_average: int = -1,):
    """
    Calculate all lresc_amounts values

    The different amount involve in the LRESC methodology for Shielding
    calculation are split in correction set (dictionaries)

    label_amounts/type_correction=
        {
        para_nr: NR paramagnetic amounts
                {"paranr": paranr}
                            paranr = [
                                    lambda a: ["angmom x", "pso " + str(1 + 3*a)],
                                    lambda a: ["angmom y", "pso " + str(1 + 3*a)],
                                    lambda a: ["angmom z", "pso " + str(1 + 3*a)],
                                    lambda a: ["angmom x", "pso " + str(2 + 3*a)],
                                    lambda a: ["angmom y", "pso " + str(2 + 3*a)],
                                    lambda a: ["angmom z", "pso " + str(2 + 3*a)],
                                    lambda a: ["angmom x", "pso " + str(3 + 3*a)],
                                    lambda a: ["angmom y", "pso " + str(3 + 3*a)],
                                    lambda a: ["angmom z", "pso " + str(3 + 3*a)],
                                    ]
        dia_nr : NR diamagnetic amounts
                {"dianr": dianr}
        triplet_lineal_amount: Correction type triplet response associated with
                                paramagnetic component
                                {"fclap": fclap,
                                "sddxx": sddxx, "sddyy": sddyy, "sddzz": sddzz,
                                ...}
        singlet_lineal_amount: Correction type singlet response associated with
                                paramagnetic component
                                {"lpsokin": lpsokin, "lkinpso": lkinpso}
        triplet_quadratic_amount: Correction type triplet response associated with
                                paramagnetic component and quadratic response
        singlet_quadratic_amount: Correction type singlet response associated with
                                paramagnetic component and quadratic response
        dia_av: Correction type average associated with diamagnetic component
                {"fc": fc, "sd": sd, "psooz": psooz, "dnske": dnske, "pnstcgop": pnstcgop}
        dia_singlet_lineal: Correction type singlet response associated with
                            diamagnetic component
        }

    Also, there are another dictionary, which indicate if the amount will be calculated, it is
    called correction

    Args:
        wf (wave_function): Wave function object
        lresc_amounts (list): Amounts will calculate
        lresc_consts (dict): Dictionary with constants for differente amounts
        atom (list): Atom index to calculate the shielding
        principal_propagator_approximation (str): Approximation
        tensor (bool): Activate calculation of all tensor components
        driver_time (drv_time): Object to manage the time calculation
        scalar_correction (bool): Activate Dw and Mv correction for energy
        verbose (int): Print level
        verbose_integrals (int): Print level for integral module
    """
    start: float = time()

    corrections, responses_amounts, averages = correction_to_calculate(lresc_amounts,
                                                                    tensor)
    ## The values of next dictionary are in include lresc_parameters.py
    label_amounts: dict = {"para_nr": paramagnetic_nr,
                    "triplet_lineal_amount": triplet_lineal_responses,
                    "singlet_lineal_amount": singlet_lineal_responses,
                    "triplet_quadratic_amount": triplet_quadratic_responses,
                    "singlet_quadratic_amount": singlet_quadratic_responses,
                    "dia_singlet_lineal": dia_singlet_lineal_responses,
                    "dia_nr": diamagnetic_nr, "dia_avs": dia_averages}

    #Hidden Print of other object
    #hidden_prints_other_object: object = HiddenPrints()
    #hidden_prints_other_object.__enter__()

    all_averages: dict = {}
    all_responses: dict = {}
    av: average = average(wf)
    moe: list = wf.mo_energies
    lineal_response: response = response(wf = wf, moe = moe)

    delta_average: float = 0.0
    delta_response: float = 0.0
    for a in atom:
        gaugeo: list = wf.coordinates[a]

        # Avarage calculation
        start_average: float = time()
        #if verbose_response <= 0 and verbose_average > 0:
        #    hidden_prints_other_object.__exit__(True,True,True)
        #else:
        #    hidden_prints_other_object.__enter__()
        atom_av: dict = {}
        for property, activate in averages.items():
            if activate:
                for name, operators in label_amounts[property].items():
                    if corrections[name]:
                        # Number of tensor components different
                        if name != "fc":
                            tensor_components: int = 9
                        else:
                            tensor_components: int = 1
                        # Diagonal (default) or all components of tensor
                        if not tensor:
                            tensor_step: int = 4
                        else:
                            tensor_step: int = 1
                        temp_av_a: list = [(lresc_consts[name]*
                                        list(av.calculate_average(
                                        property = operators[component](a),
                                        gaugeo = gaugeo,
                                        verbose = verbose_average
                                        ).values())[0])
                                        for component in range(0,tensor_components,tensor_step)]
                        if name == "fc":
                            if not tensor:
                                temp_av_a += 2*temp_av_a
                            else:
                                temp: float = temp_av_a[0]
                                temp_av_a: list = []
                                temp_av_a = [temp, 0.0, 0.0, 0.0, temp, 0.0, 0.0, 0.0, temp]
                        atom_av[name] = temp_av_a
        all_averages[a] = atom_av
        #if verbose_average < 0: hidden_prints_other_object.__exit__(True,True,True)
        delta_average += time() - start_average
        # End Average calculation

        # Response calculation
        start_response: float = time()
        # if verbose_average <= 0 and verbose_response > 0:
        #     hidden_prints_other_object.__exit__(True,True,True)
        # else:
        #     hidden_prints_other_object.__enter__()
        atom_responses: dict = {}
        sdlap_components: list =   ["sddxx", "sddxy", "sddxz",
                                    "sddyx", "sddyy", "sddyz",
                                    "sddzx", "sddzy", "sddzz"]
        sdbso_components: list =   ["sdbsoxx", "sdbsoxy", "sdbsoxz",
                                    "sdbsoyx", "sdbsoyy", "sdbsoyz",
                                    "sdbsozx", "sdbsozy", "sdbsozz"]
        lsdso_components: list =   ["lsdsoxx", "lsdsoxy", "lsdsoxz",
                                    "lsdsoyx", "lsdsoyy", "lsdsoyz",
                                    "lsdsozx", "lsdsozy", "lsdsozz"]
        for responses, activate in responses_amounts.items():
            if activate:
                for label, response_calculation in label_amounts[responses].items():
                    if corrections[label]:
                        # Diagonal (default) or all components of tensor
                        if not tensor:
                            tensor_step: int = 4
                        else:
                            tensor_step: int = 1
                        # Number of tensor components different
                        if (label not in sdlap_components
                            and label != "fclap"):
                            tensor_components: int = 9
                        else:
                            tensor_components: int = 3
                            tensor_step: int = 1
                        temp_responses_a: list = [-lresc_consts[label]
                                    *list(lineal_response.drv_reponse_calculation(
                                    gaugeo = gaugeo,
                                    principal_propagator_approximation=principal_propagator_approximation,
                                    properties = [response_calculation[component](a)],
                                    verbose=verbose_response
                                    ).values())[0]
                                    for component in range(0,tensor_components,tensor_step)]
                        atom_responses[label] = temp_responses_a
        if not tensor:
            if "sddxx" in atom_responses.keys() and "sddyy" in atom_responses.keys() and "sddzz" in atom_responses.keys():
                atom_responses["sdlap"] =   [
                                            sum(atom_responses["sddxx"]),
                                            sum(atom_responses["sddyy"]),
                                            sum(atom_responses["sddzz"])
                                        ]
                #atom_responses.pop("sddyy")
            if ("sdbsoxx" in atom_responses.keys() and
                "sdbsoyy" in atom_responses.keys() and
                "sdbsozz" in atom_responses.keys()):
                atom_responses["sdbso"] =   [
                                            sum(atom_responses["sdbsoxx"]),
                                            sum(atom_responses["sdbsoyy"]),
                                            sum(atom_responses["sdbsozz"])
                                        ]
            if ("lsdsoxx" in atom_responses.keys() and
                "lsdsoyy" in atom_responses.keys() and
                "lsdsozz" in atom_responses.keys()):
                atom_responses["lsdso"] =   [
                                            sum(atom_responses["lsdsoxx"]),
                                            sum(atom_responses["lsdsoyy"]),
                                            sum(atom_responses["lsdsozz"])
                                        ]
        else:
            if ("sddxx" in atom_responses.keys() and "sddxy" in atom_responses.keys() and "sddxz" in atom_responses.keys()
                and "sddyx" in atom_responses.keys() and "sddyy" in atom_responses.keys() and "sddyz" in atom_responses.keys()
                and "sddzx" in atom_responses.keys() and "sddzy" in atom_responses.keys() and "sddzz" in atom_responses.keys()):
                atom_responses["sdlap"] =   [
                                            sum(atom_responses["sddxx"]),
                                            sum(atom_responses["sddxy"]),
                                            sum(atom_responses["sddxz"]),
                                            sum(atom_responses["sddyx"]),
                                            sum(atom_responses["sddyy"]),
                                            sum(atom_responses["sddyz"]),
                                            sum(atom_responses["sddzx"]),
                                            sum(atom_responses["sddzy"]),
                                            sum(atom_responses["sddzz"]),
                                        ]
            if ("sdbsoxx" in atom_responses.keys() and "sdbsoxy" in atom_responses.keys() and "sdbsoxz" in atom_responses.keys()
                and "sdbsoyx" in atom_responses.keys() and "sdbsoyy" in atom_responses.keys() and "sdbsoyz" in atom_responses.keys()
                and "sdbsozx" in atom_responses.keys() and "sdbsozy" in atom_responses.keys() and "sdbsozz" in atom_responses.keys()):
                atom_responses["sdbso"] =   [
                                            sum(atom_responses["sdbsoxx"]),
                                            sum(atom_responses["sdbsoxy"]),
                                            sum(atom_responses["sdbsoxz"]),
                                            sum(atom_responses["sdbsoyx"]),
                                            sum(atom_responses["sdbsoyy"]),
                                            sum(atom_responses["sdbsoyz"]),
                                            sum(atom_responses["sdbsozx"]),
                                            sum(atom_responses["sdbsozy"]),
                                            sum(atom_responses["sdbsozz"]),
                                        ]
            if ("lsdsoxx" in atom_responses.keys() and "lsdsoxy" in atom_responses.keys() and "lsdsoxz" in atom_responses.keys()
                and "lsdsoyx" in atom_responses.keys() and "lsdsoyy" in atom_responses.keys() and "lsdsoyz" in atom_responses.keys()
                and "lsdsozx" in atom_responses.keys() and "lsdsozy" in atom_responses.keys() and "lsdsozz" in atom_responses.keys()):
                atom_responses["lsdso"] =   [
                                            sum(atom_responses["lsdsoxx"]),
                                            sum(atom_responses["lsdsoxy"]),
                                            sum(atom_responses["lsdsoxz"]),
                                            sum(atom_responses["lsdsoyx"]),
                                            sum(atom_responses["lsdsoyy"]),
                                            sum(atom_responses["lsdsoyz"]),
                                            sum(atom_responses["lsdsozx"]),
                                            sum(atom_responses["lsdsozy"]),
                                            sum(atom_responses["lsdsozz"]),
                                        ]
            if "fclap" in atom_responses.keys():
                temp: float = atom_responses["fclap"]
                atom_responses["fclap"] = [temp[0],0.0,0.0,0.0,temp[1],0.0,0.0,0.0,temp[2]]
        # Remove components of sdlap, sdbso, and lsdso
        all_responses[a] =  {
                                name: values
                                for name, values in atom_responses.items()
                                if name not in sdlap_components and name not in sdbso_components
                                and name not in lsdso_components
                            }
        delta_response += time() - start_response
        #if verbose_response < 0: hidden_prints_other_object.__exit__(True,True,True)
        # End Response calculation


    driver_time.add_name_delta_time(name = "Averages Amounts Calculations", delta_time = delta_average)
    driver_time.add_name_delta_time(name = "Responses Amounts Calculations", delta_time = delta_response)
    driver_time.add_name_delta_time(name = "LRESC Amounts Calculations", delta_time = (time() - start))

    return all_responses, all_averages

def get_shielding_iso_ani(all_responses: dict = None, all_averages: dict = None,
                        tensor: bool = False, ani_axe: str or int = "z"):
    """
    Calculate the isotropic and anisotropic value

    Args:
        all_responses (dict): Label and value of the responses
        all_averages (dict): Label and value of the averages
        tensor (bool): Responses and averages are tensors representation
        ani_axes (str or int): Axes to calculate the anisotropic value

    Returns:
        iso_averages: Isotropic value of averages
        iso_responses: Isotropic value of responses
        ani_averages: Anisotropic value of averages
        ani_responses: Anisotropic value of responses
    """

    sig_x: int = 1.0
    sig_y: int = 1.0
    sig_z: int = -1.0
    if ani_axe == 1 or ani_axe == 0 or ani_axe == "x":
        sig_x: int = -1.0
        sig_y: int = 1.0
        sig_z: int = 1.0
    elif ani_axe == 2 or ani_axe == "y":
        sig_x: int = 1.0
        sig_y: int = -1.0
        sig_z: int = 1.0

    a: int = 0
    b: int = 1
    c: int = 2
    if tensor:
        b: int = 4
        c: int = 8

    isotropic_responses: dict = {}
    anisotropic_responses: dict = {}
    isotropic_averages: dict = {}
    anisotropic_averages: dict = {}
    for atom, amounts in  all_responses.items():
        isotropic: dict = {}
        anisotropic: dict = {}
        for label, responses in amounts.items():
            isotropic[label] = (responses[a] + responses[b] + responses[c])/3.0
            anisotropic[label] = sig_x*responses[a] + sig_y*responses[b] + sig_z*responses[c]
        isotropic_responses[atom] = isotropic
        anisotropic_responses[atom] = anisotropic

    for atom, amounts in  all_averages.items():
        isotropic: dict = {}
        anisotropic: dict = {}
        for label, averages in amounts.items():
            isotropic[label] = (averages[a] + averages[b] + averages[c])/3.0
            anisotropic[label] = sig_x*averages[a] + sig_y*averages[b] + sig_z*averages[c]
        isotropic_averages[atom] = isotropic
        anisotropic_averages[atom] = anisotropic

    print(isotropic_responses)
    exit()

    return isotropic_responses, isotropic_averages, anisotropic_responses, anisotropic_averages

############## Print

def print_sinlget_lineal(responses: dict = None, ani_responses: dict = None):
    if "lpsokin" in responses.keys():
        lpsokin: float = responses["lpsokin"]
        ani_lpsokin: float = ani_responses["lpsokin"]
    else:
        lpsokin: str = "No Calc."
        ani_lpsokin: str = "No Calc."
    if "lkinpso" in responses.keys():
        lkinpso: float = responses["lkinpso"]
        ani_lkinpso: float = ani_responses["lkinpso"]
    else:
        lkinpso: str = "No Calc."
        ani_lkinpso: str = "No Calc."

    print(("<<L; {PSO, K}>>".center(20) + "   " + "<<PSO; {L, K}>>".center(20)).center(89))
    print(("|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|").center(89))
    print(("|" + f"{lpsokin:.6f}".center(18) + "|" + "   " + "|" + f"{lkinpso:.6f}".center(18) + "|").center(89))
    print(("|" + f"{ani_lpsokin:.6f}".center(18) + "|" + "   " + "|" + f"{ani_lkinpso:.6f}".center(18) + "|").center(89))
    print(("¯"*18 + "     " + "¯"*18).center(89))

def print_triplet_lineal(responses: dict = None, ani_responses: dict = None):
    if "fckin" in responses.keys():
        fckin: float = responses["fckin"]
        ani_fckin: float = ani_responses["fckin"]
    else:
        fckin: str = "No Calc."
        ani_fckin: str = "No Calc."
    if "sdkin" in responses.keys():
        sdkin: float = responses["sdkin"]
        ani_sdkin: float = ani_responses["sdkin"]
    else:
        sdkin: str = "No Calc."
        ani_sdkin: str = "No Calc."
    if "fcbso" in responses.keys():
        fcbso: float = responses["fcbso"]
        ani_fcbso: float = ani_responses["fcbso"]
    else:
        fcbso: str = "No Calc."
        ani_fcbso: str = "No Calc."
    if "sdbso" in responses.keys():
        sdbso: float = responses["sdbso"]
        ani_sdbso: float = ani_responses["sdbso"]
    else:
        sdbso: str = "No Calc."
        ani_sdbso: str = "No Calc."
    print(("<<FC; K>>".center(20) + "   " + "<<SD; K>>".center(20) + "    " +
            "<<FC; BSO>>".center(20) + "   " + "<<SD; BSO>>".center(20)).center(89))
    print(("|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|" + "   " +
            "|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|").center(89))
    print(("|" + f"{fckin:.6f}".center(18) + "|" + "   " + "|" + f"{sdkin:.6f}".center(18) + "|"
            + "   " + "|" + f"{fcbso:.6f}".center(18) + "|" + "   " + "|" + f"{sdbso:.6f}".center(18) + "|").center(89))
    print(("|" + f"{ani_fckin:.6f}".center(18) + "|" + "   " + "|" + f"{ani_sdkin:.6f}".center(18) + "|"
            + "   " + "|" + f"{ani_fcbso:.6f}".center(18) + "|" + "   " + "|" + f"{ani_sdbso:.6f}".center(18) + "|").center(89))
    print(("¯"*18 + "     " + "¯"*18 + "     " + "¯"*18 + "     " + "¯"*18).center(89))

def print_sinlget_quadratic(responses: dict = None, ani_responses: dict = None):
    if "lpsomv" in responses.keys():
        lpsomv: float = responses["lpsomv"]
        ani_lpsomv: float = ani_responses["lpsomv"]
    else:
        lpsomv: str = "No Calc."
        ani_lpsomv: str = "No Calc."
    if "lpsodw" in responses.keys():
        lpsodw: float = responses["lpsodw"]
        ani_lpsodw: float = ani_responses["lpsodw"]
    else:
        lpsodw: str = "No Calc."
        ani_lpsodw: str = "No Calc."

    print(("<<L; PSO, Mv>>".center(20) + "   " + "<<L; PSO, Dw>>".center(20)).center(89))
    print(("|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|").center(89))
    print(("|" + f"{lpsomv:.6f}".center(18) + "|" + "   " + "|" + f"{lpsodw:.6f}".center(18) + "|").center(89))
    print(("|" + f"{ani_lpsomv:.6f}".center(18) + "|" + "   " + "|" + f"{ani_lpsodw:.6f}".center(18) + "|").center(89))
    print(("¯"*18 + "     " + "¯"*18).center(89))

def print_triplet_quadratic(responses: dict = None, ani_responses: dict = None):
    if "lfcso" in responses.keys():
        lfcso: float = responses["lfcso"]
        ani_lfcso: float = ani_responses["lfcso"]
    else:
        lfcso: str = "No Calc."
        ani_lfcso: str = "No Calc."
    if "lsdso" in responses.keys():
        lsdso: float = responses["lsdso"]
        ani_lsdso: float = ani_responses["lsdso"]
    else:
        lsdso: str = "No Calc."
        ani_lsdso: str = "No Calc."

    print(("<<L; FC, SO>>".center(20) + "   " + "<<L; SD, SO>>".center(20)).center(89))
    print(("|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|").center(89))
    print(("|" + f"{lfcso:.6f}".center(18) + "|" + "   " + "|" + f"{lsdso:.6f}".center(18) + "|").center(89))
    print(("|" + f"{ani_lfcso:.6f}".center(18) + "|" + "   "
            + "|" + f"{ani_lsdso:.6f}".center(18) + "|").center(89))
    print(("¯"*18 + "     " + "¯"*18).center(89))

def print_dia_sinlget_lineal(responses: dict = None, ani_responses: dict = None):
    if "a2mv" in responses.keys():
        a2mv: float = responses["a2mv"]
        ani_a2mv: float = ani_responses["a2mv"]
    else:
        a2mv: str = "No Calc."
        ani_a2mv: str = "No Calc."
    if "a2dw" in responses.keys():
        a2dw: float = responses["a2dw"]
        ani_a2dw: float = ani_responses["a2dw"]
    else:
        a2dw: str = "No Calc."
        ani_a2dw: str = "No Calc."

    print(("<<A²; Mv>>".center(20) + "   " + "<<A²; Dw>>".center(20)).center(89))
    print(("|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|").center(89))
    print(("|" + f"{a2mv:.6f}".center(18) + "|" + "   " + "|" + f"{a2dw:.6f}".center(18) + "|").center(89))
    print(("|" + f"{ani_a2mv:.6f}".center(18) + "|" + "   "
            + "|" + f"{ani_a2dw:.6f}".center(18) + "|").center(89))
    print(("¯"*18 + "     " + "¯"*18).center(89))

def print_dia_averages(averages: dict = None, ani_averages: dict = None):
    if "fc" in averages.keys():
        fc: float = averages["fc"]
        ani_fc: float = ani_averages["fc"]
    else:
        fc: str = "No Calc."
        ani_fc: str = "No Calc."
    if "psooz" in averages.keys():
        psooz: float = averages["psooz"]
        ani_psooz: float = averages["psooz"]
    else:
        psooz: str = "No Calc."
        ani_psooz: str = "No Calc."
    if "dnske" in averages.keys():
        dnske: float = averages["dnske"]
        ani_dnske: float = averages["dnske"]
    else:
        dnske: str = "No Calc."
        ani_dnske: str = "No Calc."


    print(("<FC>".center(20) + "   " + "<PSOOZ>".center(20) + "   " + "<DNSKE>".center(20)).center(89))
    print(("|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|" + "   " + "|" + "¯"*18 + "|").center(89))
    print(("|" + f"{fc:.6f}".center(18) + "|" + "   " + "|" + f"{psooz:.6f}".center(18) + "|"
            + "   " + "|" + f"{dnske:.6f}".center(18) + "|").center(89))
    print(("|" + f"{ani_fc:.6f}".center(18) + "|" + "   " + "|" + f"{ani_psooz:.6f}".center(18) + "|"
            + "   " + "|" + f"{ani_dnske:.6f}".center(18) + "|").center(89))
    print(("¯"*18 + "     " + "¯"*18  + "     " + "¯"*18).center(89))

def print_lresc_values(isotropic_responses: dict = None, isotropic_averages: dict = None,
                        anisotropic_responses: dict = None, anisotropic_averages: dict = None,
                        atom_label: list = None):
    """
    Driver print isotropic and anisotropic results

    Args:
        isotropic_responses (dict): 
        isotropic_averages (dict): 
        anisotropic_averages (dict): 
        anisotropic_responses (dict): 
        atom_label (list): 
    """
    print()
    print(("*"*27).center(70))
    print(f"* LRESC Shielding Results *".center(70))
    print(("*"*27).center(70))

    print(f"Isotropic Values [ppm]".center(89), "\n", "and".center(89), "Anisotropic Values [ppm]".center(89))
    print(("-"*40).center(89))

    for count, atom in enumerate(isotropic_responses.keys()):

        if count > 0:
            print("\n",":"*89)
        print("\n\n",f"@@@@ Atom: {str(atom_label[atom]) + str(atom + 1):} @@@@".center(89),"\n\n")

        if "paranr" in isotropic_responses[atom].keys():
            paranr: float = isotropic_responses[atom]["paranr"]
            ani_paranr: float = anisotropic_responses[atom]["paranr"]
        else:
            paranr: str = "No Calc."
            ani_paranr: str = "No Calc."
        if "paranr" in isotropic_responses[atom].keys():
            print((f"Para".center(20)).center(89))
            print(("|" + "¯"*18 + "|").center(89))
            print(("|" + f"{paranr:.6f}".center(18) + "|").center(89))
            print(("|" + f"{ani_paranr:.6f}".center(18) + "|").center(89))
            print(("¯"*18).center(89))

    # Paramagnetic corrections
        print("\n","---> Paramagnetic Corrections <---".center(89),"\n")
        print_sinlget_lineal(isotropic_responses[atom],anisotropic_responses[atom])
        print_triplet_lineal(isotropic_responses[atom],anisotropic_responses[atom])
        print_sinlget_quadratic(isotropic_responses[atom],anisotropic_responses[atom])
        print_triplet_quadratic(isotropic_responses[atom],anisotropic_responses[atom])

        if "dianr" in isotropic_averages[atom].keys():
            dianr: float = isotropic_averages[atom]["dianr"]
            ani_dianr: float = anisotropic_averages[atom]["dianr"]
        else:
            dianr: str = "No Calc."
            ani_dianr: str = "No Calc."
        if "dianr" in isotropic_averages[atom].keys():
            print((f"Dia".center(20)).center(89))
            print(("|" + "¯"*18 + "|").center(89))
            print(("|" + f"{dianr:.6f}".center(18) + "|").center(89))
            print(("|" + f"{ani_dianr:.6f}".center(18) + "|").center(89))
            print(("¯"*18).center(89))

    # Diamagnetic corrections
        print("\n","---> Diamagnetic Corrections <---".center(89),"\n")
        print_dia_sinlget_lineal(isotropic_responses[atom],anisotropic_responses[atom])
        print_dia_averages(isotropic_averages[atom], anisotropic_averages[atom])

    # Brief results
        # -- isotropic
        lresc_para = sum([correction for label, correction in isotropic_responses[atom].items()
                            if label not in ["paranr", "a2mv", "a2dw"]])
        lresc_dia = (sum([correction for label, correction in isotropic_responses[atom].items()
                            if label in ["a2mv", "a2dw"]])
                        + sum([correction for label, correction in isotropic_averages[atom].items()
                        if label not in ["dianr"]]))
        ligand_correction = sum([correction for label, correction in isotropic_responses[atom].items()
                            if label in ["lfcso", "lsdso", "lpsodw", "lpsomv", "lpsokin", "lkinpso"]])
        core_correction = (sum([correction for label, correction in isotropic_averages[atom].items()
                            if label not in ["dianr"]])
                            + sum([correction for label, correction in isotropic_responses[atom].items()
                        if label not in ["lfcso", "lsdso", "lpsodw", "lpsomv", "lpsokin", "lkinpso"]]))
        # -- anisotropic
        ani_lresc_para = sum([correction for label, correction in anisotropic_responses[atom].items()
                            if label not in ["paranr", "a2mv", "a2dw"]])
        ani_lresc_dia = (sum([correction for label, correction in anisotropic_responses[atom].items()
                            if label in ["a2mv", "a2dw"]])
                        + sum([correction for label, correction in anisotropic_averages[atom].items()
                        if label not in ["dianr"]]))
        ani_ligand_correction = sum([correction for label, correction in anisotropic_responses[atom].items()
                            if label in ["lfcso", "lsdso", "lpsodw", "lpsomv", "lpsokin", "lkinpso"]])
        ani_core_correction = (sum([correction for label, correction in anisotropic_averages[atom].items()
                            if label not in ["dianr"]])
                            + sum([correction for label, correction in anisotropic_responses[atom].items()
                        if label not in ["lfcso", "lsdso", "lpsodw", "lpsomv", "lpsokin", "lkinpso"]]))

        print("    " + "NR".center(21) + "LRESC".center(21))
        print("    " + "Para".center(10) + " " + "Dia".center(10) + " "
                "Para".center(10) + " " + "Dia".center(10) + " "
                "NR".center(10) + " " + "LRESC".center(10) + " "
                "Total".center(10))
        print("-"*80)
        # Iso
        print("iso " + f"{paranr:.4f}".center(10) + " " + f"{dianr:.4f}".center(10) + " "
        f"{lresc_para:.4f}".center(10) + " " + f"{lresc_dia:.4f}".center(10) + " "
        f"{paranr+dianr:.4f}".center(10) + " " + f"{lresc_para + lresc_dia:.4f}".center(10)
        + " " + f"{paranr+dianr+lresc_para+lresc_dia:.4f}".center(10))
        # Ani
        print("ani " + f"{ani_paranr:.4f}".center(10) + " " + f"{ani_dianr:.4f}".center(10) + " "
        f"{ani_lresc_para:.4f}".center(10) + " " + f"{ani_lresc_dia:.4f}".center(10) + " "
        f"{ani_paranr+ani_dianr:.4f}".center(10) + " " + f"{ani_lresc_para + ani_lresc_dia:.4f}".center(10)
        + " " + f"{ani_paranr+ani_dianr+ani_lresc_para+ani_lresc_dia:.4f}".center(10))

        print(" "*25 + "-"*21)
        print("    " + " "*21 + "Ligand".center(10) + " " + "Core".center(10))
        print(" "*25 + "-"*21)
        print("iso " + " "*21 + f"{ligand_correction:.4f}".center(10) + " " + f"{core_correction:.4f}".center(10))
        print("ani " + " "*21 + f"{ani_ligand_correction:.4f}".center(10) + " " + f"{ani_core_correction:.4f}".center(10))
